{"./":{"url":"./","title":"Introduction","keywords":"","body":"KK-Index Kurisu 的知识总结索引记录 算法和数据结构 数据结构 Array LinkedList 算法 Copyright © Amatist Kurisu 2017-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-02-21 05:36:55 var className='atoc';"},"articles/dataStructure/readme.html":{"url":"articles/dataStructure/readme.html","title":"数据结构与算法","keywords":"","body":"Data Structure (数据结构) array linkedList Copyright © Amatist Kurisu 2017-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-02-21 05:36:55 var className='atoc';"},"articles/dataStructure/algorithms/readme.html":{"url":"articles/dataStructure/algorithms/readme.html","title":"算法","keywords":"","body":"Copyright © Amatist Kurisu 2017-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-02-21 05:36:55 var className='atoc';"},"articles/dataStructure/algorithms/sort.html":{"url":"articles/dataStructure/algorithms/sort.html","title":"排序","keywords":"","body":"Copyright © Amatist Kurisu 2017-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-02-21 05:36:55 var className='atoc';"},"articles/dataStructure/algorithms/dfs.html":{"url":"articles/dataStructure/algorithms/dfs.html","title":"深度优先搜索","keywords":"","body":"Copyright © Amatist Kurisu 2017-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-02-21 05:36:55 var className='atoc';"},"articles/dataStructure/algorithms/bfs.html":{"url":"articles/dataStructure/algorithms/bfs.html","title":"广度优先搜索","keywords":"","body":"Copyright © Amatist Kurisu 2017-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-02-21 05:36:55 var className='atoc';"},"articles/dataStructure/array.html":{"url":"articles/dataStructure/array.html","title":"数组","keywords":"","body":"Array [TOC] 数组的基础特性 数组是一种线性表数据结构, 使用一组连续的内存空间, 来存储一组具有相同类型的数据. 数组属于线性表结构 线性表 每个线性表上的数据最多只有前后两个方向, 除了数组 , 链表/队列/栈 也是线性表结构 相对应的, 二叉树/堆/图 等, 属于 非线性表, 在非线性表中, 数据之间并不是简单的前后关系 随机访问 数组的实现有以下两个限制: * 连续的内存空间 * 相同类型的数据 正是因为这两个限制, 所以数组支持 随机存取. 但也正是因为这两个限制, 则也导致数组中在中间位置 删除 和 插入 数据变得相对低效, 因为为了保证是连续的内存空间, 所以在中间元素被删除时 需要将后面的全部元素向前搬一位. 关于 随机存取 一词的理解: 第一次看到这个词会感到非常疑惑, \"什么? 数组还支持随机存取? 但是我通过下标访问数组难道不都是确定位置的存取吗?\" 实际上 随机存取 这个词, 如果是在数组的视角下, 那么就非常的贴切了, 数组并不知道我们下一次会访问访问哪一个位置, 这个访问对他来说是随机的, 同时对于我们来说也是, 我们可以随意跳至我们想要去的位置. 与 随机存储 这个概念相对的是 顺序访问, 也就是需要一个一个遍历到我们想要的位置, 举个例子, 链表, 在链表中, 我们如果想要访问一个中间元素, 我们必须从链表的第一个节点一直遍历到那一个中间节点, 而无法直接访问到我们想要的那个中间节点. 那么为什么数组可以高效的随机访问数组元素呢? 我们回到数组的两个限制, 在第二个限制中, 要求数组中的元素都是相同的数据类型, 那么相同的数据类型, 也就意味着占用的内存空间相同, 那么这样, 我们就可以通过计算 需要访问的下标 和 元素的内存空间 得到偏移量, 然后将 数组内存块的首地址 加上 偏移量, 得到我们需要访问的元素的内存地址. 然后直接访问便可, 所以数组通过下标随机访问的时间复杂度是 O(1) 低效的 插入与删除 因为 连续内存空间的特性, 所以在向数组中间插入或删除时 , 需要保证空间的连续性, 所以需要将后面的元素全部前移一位或者后移一位, 这种操作最坏的时间复杂度是 O(n). 但是在某些特殊场景下, 对这种低效插入和低效删除有一定的优化空间. 低效插入 如果 当前数组只是被当做一个存储数据的集合, 这种情况下, 我们为了避免大规模的数据搬移, 可以将 k 位置的元素挪到数组的最后, 然后把元素插入到 k 的位置上. 低效删除 低效删除的应对方式是懒惰删除, 在底层实现时, 对于被删除的数组元素, 我们仅仅只是记录下该元素已经被删除, 而不是真正的删除和搬动数据. 等到合适的时机时, 例如 数组空间不够,或者达到阈值时, 再一次性进行删除, 这样就大大的减少了删除操作导致的数据搬移. JVM 的标记清除垃圾回收算法 和这个原理类似. 极客时间-数据结构与算法之美 很多时候我们并不是要去死记硬背某个数据结构或者算法, 而是要学习它背后的思想和处理技巧, 这些东西才是最有价值的. 数组越界 在 C 语言中, 数组越界是一种未决行为, 并没有规定数组访问越界时, 编译器应该如何处理, 并且 访问数组的本质就是访问一段连续内存. 而在 C语言中, 只要不是访问受限的内存, 理论上所有的内存空间都是可以只有访问的. 所以 只要数组通过偏移计算得到的内存地址是可用的, 那么 程序就可能不会报任何错误. 正因为如此, 很多计算机恶意程序 都是通过 数组越界的方式 非法访问内存地址的漏洞, 来攻击系统. 以上部分内容 在 \"极客时间\" - 数据结构于算法之美 的基础上进行再演绎和修改 Problem List LeetCode xxx.ProblemName xxx.ProblemName xxx.ProblemName xxx.ProblemName xxx.ProblemName xxx.ProblemName xxx.ProblemName xxx.ProblemName Copyright © Amatist Kurisu 2017-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-02-21 05:36:55 var className='atoc';"},"articles/dataStructure/linkedList.html":{"url":"articles/dataStructure/linkedList.html","title":"链表","keywords":"","body":"LinkedList [TOC] 链表的基本特性 链表和数组不同, 链表不需要连续的内存空间. 链表通常分为三种: 单链表 双向链表 循环链表 单链表 单链表通常通过指针将一组零散的内存块串联在一起. Problem List LeetCode xxx.ProblemName xxx.ProblemName xxx.ProblemName xxx.ProblemName Copyright © Amatist Kurisu 2017-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-02-21 05:36:55 var className='atoc';"},"articles/networkProtocol.html":{"url":"articles/networkProtocol.html","title":"网络协议","keywords":"","body":"Copyright © Amatist Kurisu 2017-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-02-21 05:36:55 var className='atoc';"},"articles/redis.html":{"url":"articles/redis.html","title":"redis","keywords":"","body":"https://www.cnblogs.com/xingzc/p/5988080.html https://juejin.im/post/5d09a9ff51882577eb133aa9 Redis 的 RDB 持久化 和 AOF 持久化的区别 RDB AOF Copyright © Amatist Kurisu 2017-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-02-21 05:36:55 var className='atoc';"},"articles/distributed/readme.html":{"url":"articles/distributed/readme.html","title":"分布式","keywords":"","body":"Copyright © Amatist Kurisu 2017-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-02-21 05:36:55 var className='atoc';"},"articles/distributed/CAP.html":{"url":"articles/distributed/CAP.html","title":"CAP","keywords":"","body":"CAP - 分布式系统的三个指标 CAP 是以下三个单词的首字母拼成, Consistency (一致性) Availability (可用性) Partition tolerance (分区容错性) 由加州大学 Eric Brewer 提出, 并且给出 CAP 三个指标不可能同时做到的猜想. 也称为 CAP 定理 Consistency 一致性 一致性指 在所有节点访问能访问到同一份最新的数据副本, 这个很好理解, 例如在 数据库分库后, 我们需要保证读库和写库的数据一致性. 在并发读写时非常容易出现一致性问题, 所以在考虑一致性问题是, 要注意结合并发读写的场景. 通常有三种一致性策略 对于关系型数据库, 要求更新过的数据能被后续的访问都看到, 这是 强一致性 如果能容忍后续的 一部分 或者 全部 访问不到, 则是 弱一致性 如果经过一段时间后 要求能访问到更新后的数据, 则是 最终一致性 CAP 中的 一致性 指的是 强一致性 Availability 可用性 可用性也就是说 这个节点 或者 服务 是一直可以正常响应请求的. 这和 利用多副本实现无状态节点的高可用 中的 可用 是相同的意思. 通常通过 停机时间 来衡量一个系统的可用性. 可用性分类 可用水平 年可容忍停机时间 容错可用性 99.9999 极高可用性 99.999 具有故障自动恢复能力的可用性 99.99 高可用性 99.9 商品可用性 99 计算停机时间的公式如下 (1- 可用水平百分数)*365*24*60 得到 全年可容忍的停机时间 分钟数 Partition Tolerance (分区容忍度) 对于 Partition Tolerance , 通常有些文献中被翻译成 分区容错性 , 个人觉得这样容易产生歧义, 更贴切的翻译个人认为是 分区容忍性 以下来自 邬江 - CAP 理论中的 P 到底是个什么意思? 的回答 - 知乎 一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中。这就叫分区。 当你一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的。 提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项就可能分布到各个区里。容忍性就提高了。 然而，要把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题。 总的来说就是，数据存在的节点越多，分区容忍性越高，但要复制更新的数据就越多，一致性就越难保证。为了保证一致性，更新所有节点数据所需要的时间就越长，可用性就会降低。 为何 C/A/P 三者中会出现 \"三选二\" 的情况 想象一种这样一种情况, 在两个可用区 A,B 中, 分别有服务器 AS1,BS1 和数据库 AD1 和 BD1, 同时, AD1和BD1两台数据库之间做了数据同步, 这样就变成了一个标准的双可用区部署. 此时, 客户端无论是从 AS1上访问还是从 BS1 上访问和操作, 都可以得到同样的结果. 用户访问 用户访问 v v |-----| |-----| | AS1 (服务器) | BS1 (服务器) | | | | | | | | | AD1 (数据库) | BD1 (数据库) |-----| |-----| 但是当同步中断时,也就是我们的一整个集群被网络故障切割成了两个, 在 C 和 A 我们将只能选择保证其一 当 BD1 有数据写入时, 因为中间的同步已经断开, 那么为了保证数据的一致性, 我们只有牺牲可用性, 等到网络故障恢复后, 再提供服务 假设在上面的情况下我们选择为了保证服务可用性, 而牺牲数据的一致性, 我们会响应旧的数据给用户 所以这样就得出结论, 在需要容忍分区割裂的分布式系统中, 只能在数据一致性和服务可用性间二选一. 再根据业务特点进行妥协和优化 CAP 权衡 AP without C 做到服务的高可用并容忍被网络分区的话, 我们需放弃一致性, 使用这种案例的场景很多, 例如 在高并发场景下, 一旦 数据库宕机 或者 数据库负载过高处理过慢 或者 调用链路中的某一环挂掉, 那么就形成了 P 的状态, 此时我们仍需继续处理请求并等待服务恢复, 常见的案例有 12306 的购票, 以及 双十一淘宝 CP without A CA without P What's Next ACID BASE ref: > hollis - 分布式系统的 CAP 理论 (通俗易懂, 推荐) 邬江 - CAP 理论中的 P 到底是个什么意思? 的回答 - 知乎 wiki-CAP infoQ-CAP 理论十二年回顾：\"规则\"变了 Copyright © Amatist Kurisu 2017-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-02-21 05:36:55 var className='atoc';"},"articles/golangPkg.html":{"url":"articles/golangPkg.html","title":"golang pkg","keywords":"","body":"Copyright © Amatist Kurisu 2017-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-02-21 05:36:55 var className='atoc';"}}